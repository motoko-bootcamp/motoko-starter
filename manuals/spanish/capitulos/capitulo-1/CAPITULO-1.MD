# Cap칤tulo 1: Conceptos Fundamentales
## 쯈u칠 es un Canister?
Hay una palabra que necesitas dominar absolutamente durante esta semana. 쮼st치s listo? Es... 游볘... **CANISTER**!

El Internet Computer es una plataforma que aloja una gran cantidad de aplicaciones, todas las cuales se ejecutan sin problemas en contenedores especiales llamados **canisters**.

- El Internet Computer se encarga de ejecutar de manera fluida y segura todos los canisters implementados en la plataforma en paralelo.
- Los desarrolladores construyen aplicaciones escribiendo c칩digo fuente para esos canisters. Una aplicaci칩n puede estar compuesta por uno o varios canisters dependiendo de la arquitectura.
- Los usuarios interact칰an con las aplicaciones enviando mensajes a los canisters. Esto sucede cada vez que usas una aplicaci칩n en el Internet Computer e interact칰as con ella; algunos ejemplos de tales interacciones son:
    - Cuando publicas en una red social.
    - Cuando env칤as un token a otra direcci칩n.
    - Cuando compras o vendes un NFT.
    - Cuando lees contenido en un sitio web alojado en el Internet Computer.
    - 춰Y muchos m치s!

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/oc_message.png" height="600px" style="border: 1px solid black;"/> </p>
<p align="center"> OpenChat es una aplicaci칩n de mensajer칤a descentralizada construida en el Internet Computer. </p>

## WebAssembly
Antes de pasar a Motoko, en realidad necesitamos explicar otro t칠rmino: **WebAssembly**.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/canister_overview.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Vista general de un canister.</p>

Si profundizamos en un canister, est치 compuesto por:
- Un **m칩dulo WebAssembly** que es un fragmento de c칩digo compilado a partir de lenguajes como Rust o Motoko. Este es el c칩digo que se instala en el canister y que finalmente se ejecuta.
- Una **memoria WebAssembly** - tambi칠n llamada p치ginas de memoria. Aqu칤 es donde se almacena el estado del canister y se almacenan archivos (fotos, videos, tokens...). El c칩digo que se ejecuta en el m칩dulo WebAssembly modificar치 la memoria.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/webassembly.png" width="600px" style="border: 2px solid black;"> </p>

<p align="center"> 쯈u칠 es <b>WebAssembly</b>? </p>
WebAssembly es un formato binario de bajo nivel para ejecutar c칩digo en m칰ltiples entornos (navegadores, plataformas en la nube, dispositivos inteligentes, m치quinas virtuales...). Los principales beneficios de usar WebAssembly son:

- **WebAssembly** admite c칩digo escrito en varios lenguajes (C, C++, Rust, Motoko), lo que lo convierte en una soluci칩n vers치til para los desarrolladores.
- El c칩digo de **WebAssembly** es portable y puede ejecutarse en casi cualquier dispositivo. 춰Lo escribes una vez y lo ejecutas en cualquier lugar!
<p align="center"> <img src="../../../capitulos/capitulo-1/assets/webassembly_stack.png" width="500px" style="border: 1px solid black;"/> </p>
<p align="center"> Escribe una vez, implementa en cualquier plataforma. </p>

- **WebAssembly** es r치pido. Es un lenguaje muy cercano al lenguaje de m치quina y ha sido optimizado para la velocidad y el rendimiento. 춰Puedes usarlo para crear aplicaciones complejas e intensivas (juegos, simulaciones, gr치ficos)!
- **WebAssembly** proporciona un entorno de ejecuci칩n seguro, colocando el c칩digo en un 치rea especial llamada sandbox. El sandbox asegura que el programa solo pueda hacer cosas y acceder a los recursos a los que se le ha otorgado acceso y no permite que acceda a informaci칩n confidencial. Esto es muy 칰til cuando se intenta escribir c칩digo seguro o para que los usuarios se aseguren de que no ser치n da침ados por el c칩digo que se ejecuta en su m치quina.

El 칰nico problema con **WebAssembly** es que es un lenguaje de bajo nivel y proporciona muy poca abstracci칩n, lo que dificulta su uso para escribir aplicaciones complejas como dApps (aplicaciones descentralizadas).

## El Lenguaje Motoko
<p align="center"> <img src="../../../capitulos/capitulo-1/assets/motoko_banner.png" width="600px" style="border: 1px solid black;"/> </p>

Es por eso que la [Fundaci칩n DFINITY](https://dfinity.org/) ha introducido un nuevo lenguaje llamado **Motoko**, que es un lenguaje de programaci칩n espec칤ficamente dise침ado para crear dApps en el Internet Computer. Dado que el c칩digo de Motoko se puede compilar directamente en **WebAssembly**, es un lenguaje incre칤ble para construir en el Internet Computer. Motoko es un lenguaje de alto nivel y f치cil de usar. Escribes en Motoko y luego se compila en WebAssembly.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/motoko_to_wasm.png" width="600px" style="border: 1px solid black;"/> </p>
<p align="center"> En Motoko escribes el c칩digo, en WebAssembly se ejecuta.</p>

> Vale la pena se침alar que WebAssembly fue co-dise침ado por [Andreas Rossberg](https://github.com/rossberg), quien se uni칩 a la Fundaci칩n DFINITY a principios de 2017 para trabajar en su entorno de ejecuci칩n de contratos inteligentes de canister y tambi칠n es el dise침ador original del lenguaje Motoko. El est치ndar es mantenido por el [World Wide Web Consortium](https://www.w3.org/).

En el siguiente ejemplo, aqu칤 hay una funci칩n `factorial` ilustrada en **Motoko** y **WebAssembly**.
춰No te preocupes si no entiendes nada, es normal!

<table align="center">
  <tr>
    <th> Motoko </th>
    <th>WebAssembly</th>
  </tr>
  <tr>
    <td> <pre> func factorial(n : Nat) : Nat { if (n == 0) { return 1; } else { return n * factorial(n - 1); } } </pre> </td>
    <td> <pre> (func $factorial (param $n i32) (result i32) (if (result i32) (i32.eqz (get_local $n)) (i32.const 1) (i32.mul (get_local $n) (call $factorial (i32.sub (get_local $n) (i32.const 1)))))) </pre> </td>

<td><pre>
20 00
42 00
51
04 7e
42 01
05
20 00
20 00
42 01
7d
10 00
7e
0b
</pre></td>
</tr>
</table><p align="center"> 쯈u칠 piensas? 쯊e parece m치s f치cil escribir esta funci칩n con <b>Motoko</b>? </p>

Un archivo de Motoko es un archivo con la extensi칩n `.mo`.

<p align="center"> <img src="./assets/mo_extension.png" width="300px" style="border: 2px solid black;"> </p>

**Motoko** es un lenguaje de alto nivel como **JavaScript** o **Python**. En general, se considera m치s f치cil de aprender que un lenguaje de nivel inferior como **Rust** o **C**. 

---
<i> Motoko tiene una mascota genial que ha sido intensamente utilizada y modificada en la comunidad, 춰para todo tipo de prop칩sitos! 
As칤 que no solo podr치s construir aplicaciones descentralizadas de vanguardia con Motoko, sino que tambi칠n tendr치s el logo m치s genial del juego. 쯅o nos crees? Solo mira el [mercado de Motoko NFT](https://entrepot.app/marketplace/motoko) y compru칠balo t칰 mismo. </i>

## El modelo de actor.
Si abres un archivo de Motoko, hay una alta probabilidad de que la primera palabra que leer치s sea `actor`:
```
actor {

    /// CODE

};
````
Un **actor** es c칩mo se representa y abstrae un canister en **Motoko**. Este t칠rmino proviene del [modelo de actor](https://es.wikipedia.org/wiki/Modelo_de_actor) que es una forma de escribir programas de computadora que pueden manejar muchas tareas al mismo tiempo. Lo hace tratando a los **actores** como los bloques de construcci칩n b치sicos de un programa. <br/>
Un actor es un peque침o programa de computadora que puede recibir mensajes, hacer alg칰n trabajo y luego enviar mensajes a otros actores. Los actores tambi칠n pueden crear nuevos actores y controlarlos. Todos los actores se comunican entre s칤 enviando mensajes. Dado que toda la interacci칩n entre actores se realiza mediante el paso de mensajes, esto permite niveles muy altos de concurrencia y paralelismo, lo que lo hace muy adecuado para sistemas distribuidos. En ese sentido, 춰el Internet Computer es una computadora distribuida donde cada programa es un canister!

Dado que los canisters se han implementado para seguir el modelo de actor, no te sorprender치 saber que los canisters:

- Tienen un estado privado (memoria) y pueden ejecutar c치lculos.
- Reciben mensajes de usuarios u otros canisters.
- Pueden enviar mensajes a usuarios u otros canisters.
- Pueden crear otros canisters.


<p align="center"> <img src="./assets/actor_model.gif" width="800px" style="border: 2px solid black;"></p>
<p align="center">Un canister recibe un mensaje, lo ejecuta y posiblemente env칤a otros mensajes a otros canisters (o incluso crear nuevos) en respuesta. </p>

Ahora consideremos el siguiente actor:
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```
Podemos ver que este actor tiene:
- Una variable llamada `message`, que se inicializa con un valor `Hello Motoko Bootcamp`.
- Dos funciones p칰blicas:
    - `changeMessage` que actualiza el valor de `message` a lo que se proporcione como argumento.
    - `readMessage` que muestra el valor de `message` sin modificarlo.

La palabra clave `public` indica que ambas funciones pueden ser llamadas desde el exterior por usuarios u otros canisters. Las funciones `public` de un actor representan la [API](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones) del canister.
## Actualizar vs Consultar
쮿as notado la palabra clave `query` en el ejemplo anterior?
<br/> Cuando un usuario llama a un canister, es importante distinguir dos tipos de llamadas:

### Llamadas de actualizaci칩n
Las llamadas de actualizaci칩n se utilizan cuando el usuario desea modificar el estado de un canister. Para garantizar la integridad del Internet Computer, estas llamadas deben procesarse a trav칠s del consenso y por todos los nodos, lo que resulta en un retraso de alrededor de 1-2 segundos. Se utilizar칤a una llamada de actualizaci칩n en las siguientes situaciones:
- Publicar en una red social, como [DSCVR](https://dscvr.one/).
- Enviar un mensaje en una aplicaci칩n de mensajer칤a, como [OpenChat](https://oc.app/).
- Dar me gusta o compartir un contenido en [Distrikt](https://az5sd-cqaaa-aaaae-aaarq-cai.ic0.app/).
- Comprar un NFT en [Entrepot](https://entrepot.app/).

<p align="center"> <img src="./assets/update_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

### Llamadas de consulta
Este tipo de llamada se utiliza cuando un usuario desea leer datos sin modificar el estado. Estas llamadas pueden ser respondidas por un solo nodo, lo que las hace muy r치pidas (alrededor de 200ms). El inconveniente es que las llamadas de **consulta** son menos seguras ya que un nodo malintencionado podr칤a proporcionar informaci칩n falsa. Se utilizar칤a una llamada de consulta en las siguientes situaciones:
- Leer un art칤culo en [Nuance](https://nuance.xyz/).
- Verificar tu foto de perfil de usuario en 
- Cargar un video o una imagen en cualquier plataforma.

<p align="center"> <img src="./assets/query_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

> Dado que una llamada de consulta omite el consenso y depende de un solo nodo, es menos segura que una llamada de actualizaci칩n.


|  | Llamada de actualizaci칩n | Llamada de consulta |
|-----------------|-----------------|-----------------|
Tiempo de respuesta | 2-5 segundos 游냑  | 200-400 ms 丘뫮잺  |
Consenso| S칤 |No |  
Leer | S칤 | S칤 |
Escribir| S칤 | No |
Costo | Ciclos de costo | Gratis (por ahora)


Volviendo a nuestro actor anterior:
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```

La palabra clave `query` nos indica que la funci칩n `readMessage` solo se utiliza para leer informaci칩n. Por otro lado, `changeMessage` puede actualizar el estado (no es necesario agregar la palabra clave `update` ya que se asume por defecto).

> Hemos implementado el actor anterior en el Internet Computer - y puedes acceder a <a href="https://a4gq6-oaaaa-aaaab-qaa4q-cai.raw.ic0.app/?id=rhjue-eaaaa-aaaaj-qazra-cai" target="_blank">su API</a>. Prueba la interfaz y comprueba la diferencia de velocidad entre `changeMessage` y `readMessage`. Divi칠rtete y deja un mensaje amable para el pr칩ximo estudiante.

## Combustible en el Internet Computer: ciclos.
Para pagar los costos de computaci칩n y almacenamiento, los canisters deben estar cargados con **ciclos**.
Cada canister tiene su propio saldo de **ciclos** - esto se puede pensar como la vida 칰til de la bater칤a de un **canister**. 
Los **ciclos** se pueden obtener quemando **ICP**.

<p align="center"> <img src="./assets/cycles_burned.gif" width="600px" style="border: 2px solid black;"> </p>
<p align="center"> Al procesar un nuevo mensaje, se deducen ciclos del saldo del canister y se queman.</p>

A diferencia del **gas** en **Ethereum**, los **ciclos** en el **Internet Computer** no son pagados por el usuario. Esto significa que puedes interactuar con canisters y navegar por sitios web sin pagar nada. Esto se conoce como el modelo de **gas inverso** y es una gran mejora para la experiencia del usuario, ya que elimina la necesidad de crear billeteras, mantener tokens y pagar tarifas altas.

Los ciclos se miden en billones (T), lo que equivale a 1.000.000.000.000 o 10^12. Un bill칩n de ciclos siempre cuesta 1 XDR, que es una moneda basada en las tasas de cambio del mercado que representa una canasta de principales monedas. A partir de ahora, 1 XDR equivale a $1,34. El precio de los ciclos no se ve afectado por el precio de los tokens ICP. En su lugar, la tasa de conversi칩n de los tokens ICP a ciclos se ajusta constantemente mediante el seguimiento del precio de ICP.

Cada operaci칩n realizada en la red tiene un costo asociado:
- Creaci칩n de un canister.
- Ejecuci칩n de un mensaje de actualizaci칩n.
- Ejecuci칩n de una llamada entre canisters.
- Almacenamiento de datos.
- Realizaci칩n de una llamada HTTPS.
- C치lculo de una firma ECDSA de umbral.

El costo de esas operaciones tambi칠n depende de la subred en la que se realizan y del **factor de replicaci칩n** de esta subred. El factor de replicaci칩n corresponde al n칰mero de nodos en una subred, que puede variar de 13 a 40.
