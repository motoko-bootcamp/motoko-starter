# El Verificador ğŸ‘¨â€ğŸ«
## IntroducciÃ³n
Imagina que eres un instructor en [Motoko School](https://twitter.com/MotokoSchool), donde actualmente supervisas a una cohorte de mÃ¡s de 200 estudiantes dedicados. ğŸ¤¯ <br/>
Como parte del programa, has asignado a estos ambiciosos aprendices a abordar 4 proyectos distintos, cada uno diseÃ±ado para desafiar sus habilidades y conocimientos. Al completarlos, recae sobre tus hombros revisar y evaluar meticulosamente su trabajo, determinando en Ãºltima instancia si han cumplido con los criterios para [graduarse](../../../README.MD#ğŸ“-graduation). <br/>
Afortunadamente, como desarrollador experto en Motoko tÃº mismo, posees la experiencia y la confianza para simplificar este proceso de verificaciÃ³n mediante la automatizaciÃ³n. Este enfoque innovador no solo te ahorrarÃ¡ tiempo valioso, sino que tambiÃ©n pavimentarÃ¡ el camino para el futuro del **Motoko Bootcamp**. Â¡Comencemos!
## ğŸ§‘â€ğŸ« Requisitos
Tu tarea es crear el cÃ³digo para un **instructor**, que se implementa como un canister. La idea es que el estudiante ingrese su id de canister y se verifique automÃ¡ticamente por el canister. Si el id de canister enviado cumple con los requisitos, los estudiantes se graduarÃ¡n automÃ¡ticamente; Â¡imagina las horas de trabajo que ahorrarÃ¡s! <br/>

[AGREGAR ILUSTRACIÃ“N]

> Para el propÃ³sito de este Bootcamp, no intentaremos construir un verificador que pruebe los 4 proyectos anteriores. Solo intentaremos verificar una versiÃ³n simple de la calculadora que implementaste durante el DÃ­a 1. El cÃ³digo para esta calculadora simple ya ha sido implementado y se puede encontrar [aquÃ­](../project/calculator/main.mo).

## Parte 1: Almacenar informaciÃ³n de los estudiantes.
La idea en esta secciÃ³n es construir el cÃ³digo para almacenar informaciÃ³n sobre los estudiantes.
### Paso a paso
Un perfil de estudiante se define de la siguiente manera:
```motoko
public type StudentProfile = {
    name : Text;
    Team : Text;
    graduate : Bool;
};
```
1. Define una variable llamada `studentProfileStore`, que es un `HashMap` para almacenar el perfil de los estudiantes. Las claves en este mapa son de tipo `Principal` y representan la identidad de los estudiantes, mientras que los valores son de tipo `StudentProfile`.
2. Implementa la funciÃ³n `addMyProfile` que acepta un `perfil` de tipo `StudentProfile` y lo agrega al `studentProfileStore`. Esta funciÃ³n asume que el `caller` es el estudiante correspondiente al perfil.
```motoko
addMyProfile: shared (profile : StudentProfile) -> async Result.Result<(), Text>;
```
3. Implementa la funciÃ³n de consulta `seeAProfile`, que acepta un principal `p` de tipo `Principal` y devuelve el perfil del estudiante correspondiente (si existe) como un valor opcional.
```motoko
seeAProfile : query (p : Principal) -> async ?StudentProfile;
```
4. Implementa la funciÃ³n `updateMyProfile` que permite a un estudiante realizar una modificaciÃ³n en su perfil de estudiante. Si todo funciona, y el perfil se actualiza, la funciÃ³n debe devolver un valor unitario simple envuelto en un resultado `Ok`. Si el `caller` no tiene un perfil de estudiante, la funciÃ³n debe devolver un mensaje de error envuelto en un resultado `Err`.
```motoko
updateMyProfile : shared (profile : StudentProfile) -> async Result.Result<(), Text>;
```
5. Implementa la funciÃ³n `deleteMyProfile` que permite a un estudiante eliminar su perfil de estudiante. Si todo funciona y el perfil se elimina, la funciÃ³n debe devolver un valor unitario simple envuelto en un resultado `Ok`. Si el `caller` no tiene un perfil de estudiante, la funciÃ³n debe devolver un mensaje de error envuelto en un resultado `Err`.
```motoko
deleteMyProfile : shared (profile : StudentProfile) -> async Result.Result<(), Text>;
```
6. AsegÃºrate de que `studentProfileStore` sea resistente a las actualizaciones, lo que significa que todos los perfiles de estudiantes se conservarÃ¡n incluso si el canister se actualiza. Implementa esto utilizando los ganchos `pre_upgrade` y `post_upgrade`.

## Parte 2: Pruebas de la calculadora simple.
La idea en esta secciÃ³n es implementar el cÃ³digo que realiza la prueba en la calculadora simple.
Vamos a probar:
- La funciÃ³n `reset`.
- La funciÃ³n `add`.
- La funciÃ³n `sub`.

Si esas tres funciones se implementan correctamente, entonces la prueba es positiva y se valida el canister.

### Paso a paso
El tipo `TestResult` se define de la siguiente manera:
```motoko
    public type TestResult = Result.Result<(), TestError>;
    public type TestError = {
        #UnexpectedValue : Text;
        #UnexpectedError : Text;
    };
```
1. Implementa la funciÃ³n `test` que toma un `canisterId` de tipo `Principal` y devuelve el resultado de la prueba de tipo `TestResult`. AsegÃºrate de distinguir entre los dos tipos de errores.

- Se debe devolver `UnexpectedValue` cada vez que la calculadora devuelve un valor incorrecto. Por ejemplo, si una llamada a `reset` seguida de `add(1)` devuelve 2.
- Se debe devolver `UnexpectedError` para todos los demÃ¡s tipos de errores. Por ejemplo, si la funciÃ³n `add` ni siquiera estÃ¡ implementada como parte de la interfaz del canister.
```motoko
test: shared (canisterId : Principal) -> async TestResult;
```

## Parte 3: Verificar el controlador de la calculadora.
En esta secciÃ³n queremos asegurarnos de que el propietario del canister verificado sea realmente el estudiante que lo registrÃ³. De lo contrario, un estudiante podrÃ­a usar el canister de otro.
### Paso a paso
1. Implementa la funciÃ³n `verifyOwnership` que toma un `canisterId` de tipo `Principal` y un `principalId` de tipo `Principal` y devuelve un booleano que indica si el `principalId` estÃ¡ entre los controladores del canister correspondiente al `canisterId` proporcionado.

> Desafortunadamente, a partir de hoy, el mÃ©todo `canister_status` del canister de administraciÃ³n solo se puede usar cuando el canister que lo llama tambiÃ©n es uno de los controladores del canister que estÃ¡s intentando verificar. [Lee el tema dedicado para obtener mÃ¡s informaciÃ³n](https://forum.dfinity.org/t/how-to-find-out-the-controllers-of-a-canister/14345/3).

## Parte 4: Â¡GraduaciÃ³n!
En esta secciÃ³n, la idea es permitir que los estudiantes envÃ­en su trabajo y verifiquen automÃ¡ticamente el canister. Si se aprueban las pruebas, el campo `graduation` del estudiante se cambia automÃ¡ticamente.
1. Implementa la funciÃ³n `verifyWork` que toma un `canisterId` de tipo `Principal` y realiza las verificaciones necesarias en el canister. Si se validan todos los criterios para la graduaciÃ³n, entonces el campo `graduation` se actualiza en consecuencia.

## Parte 5: Lista de graduados ğŸ“
En esta secciÃ³n, la idea es implementar una funciÃ³n para manejar solicitudes HTTP dentro del canister verificador. Cualquiera deberÃ­a poder ir a ...

1. Crea un `Array` llamado `graduates` que almacena el nombre de los graduados.
2. Implementa un temporizador para que el array se actualice cada hora.
3. Implementa el mÃ©todo `http_request`.

## ğŸ“º Interfaz
> Al final del proyecto, tu canister debe implementar la siguiente interfaz:
```motoko
actor Verifier {

};
```

