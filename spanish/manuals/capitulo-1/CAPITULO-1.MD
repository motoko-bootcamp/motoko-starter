# Chapter 1: Fundamental concepts.
##  쯈u칠 es un canister?
Hay una palabra que necesitas dominar absolutamente de toda esta semana. 쮼st치s listo? 
Es... 游볘... **CANISTER**! 

El Internet Computer es una plataforma que aloja un gran n칰mero de aplicaciones, todas estas aplicaciones se ejecutan sin problema dentro de los contenedores especiales llamados **canisters**. 

- El Internet Computer es responsable de ejecutar sin problema y con seguridad todos los canisters desplegados en la plataforma en paralelo.
- Los desarrolladores construyen aplicaciones escribiendo el c칩digo fuente para esos canisters. Una aplicaci칩n puede ser construida en uno o varios canisters dependiendo de la arquitectura.
- Los usuarios interact칰an con las aplicaciones mediante el env칤o de mensajes a los canisters. Esto pasa siempre que usas una aplicaci칩n en el Internet Computer e interact칰as con ella - unos ejemplos de dicha interacciones son:
    - Cuando publicas en una red social.
    - Cuando env칤as un token a otra direcci칩n.
    - Cuando vendes o compras un NFT.
    - Cuando lees contenido en un sitio web alojado en el Internet Computer.
    - Y muchas m치s...

<p align="center"> <img src="./assets/oc_message.png" height="600px" style="border: 1px solid black;"/> </p>
<p align="center"> OpenChat es una aplicaci칩n de mensajes descentralizada desarrollada en el Internet Computer. </p>

## WebAssembly
Antes de empezar con Motoko - necesitamos explicar otro t칠rmino: **WebAssembly**.

<p align="center"> <img src="./assets/canister_overview.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Vista general de un canister.</p>

Si hacemos zoom dentro de un canister podemos observar que esta compuesto de:
- Un **WebAssembly module** el cual es una pieza de c칩digo compilado de lenguajes como Rust o Motoko. Este es el c칩digo que es instalado en el canister y en 칰ltima instancia es ejecutado. 
-  **WebAssembly memory** - tambi칠n llamadas p치ginas de memoria. Aqu칤 es donde el estado del canister es almacenado y los documentos son almacenados (fotos, videos, tokens...). El c칩digo ejecutado por el WebAssembly module modificara la memoria.

<p align="center"> <img src="./assets/webassembly.png" width="600px" style="border: 2px solid black;"> </p>

<p align="center"> 쯈u칠 es <b> WebAssembly </b>? <p>
WebAssembly es un formato binario de bajo nivel para ejecutar c칩digo de m칰ltiples entornos  (browsers, cloud platform, smart devices, virtual machine..). Los beneficios principales de usar WebAssembly son, 

- **WebAssembly** admite c칩digo escrito en m칰ltiples lenguajes (C, C++, Rust, Motoko) haciendo de esta una soluci칩n vers치til para los desarrolladores.
- **WebAssembly** code es  portable y se puede ejecutar en casi cualquier dispositivo.Lo escribes una vez y puedes ejecutarlo en cualquier lugar!
<p align="center"> <img src="./assets/webassembly_stack.png" width="500px" style="border: 1px solid black;"/> </p>
<p align="center"> Escribe una vez y se despliega en cualquier plataforma. </p>

- **WebAssembly** es r치pido. Es un lenguaje que es cercano al  lenguaje de la m치quina y ha sido optimizado para aumentar la velocidad y el rendimiento. Puedes usarlo para crear aplicaciones complejas e intensivas (Juegos,simulaciones, gr치ficos)!
- **WebAssembly** proporciona un entorno de ejecuci칩n seguro, colocando el c칩digo en una zona especial denominada sandbox (caja de arena).  Sandbox se asegura de que el programa es solamente capaz de hacer cosas y acceder a recursos a los que se le ha concedido acceso y bi se le permite acceder a informaci칩n sensible. Esto ayuda bastante cuando tratamos de escribir c칩digo seguro o para que los usuarios se aseguren de que no se ver치n perjudicados por la ejecuci칩n del c칩digo en sus m치quinas.


El 칰nico problema con **WebAssembly** es que es un lenguaje de bajo nivel  y este provee muy poca abstracci칩n, haciendo dif칤cil su uso para escribir aplicaciones complejas como dApps (aplicaciones descentralizadas).

## El lenguaje Motoko
<p align="center"> <img src="./assets/motoko_banner.png" width="600px" style="border: 1px solid black;"/> </p>

Este es el porque  [DFINITY Foundation](https://dfinity.org/) ha creado un nuevo lenguaje llamado **Motoko**, el cual es un lenguaje de programaci칩n dise침ado espec칤ficamente para crear aplicaciones descentralizadas (dApps) en el  Internet Computer. Desde que el c칩digo de Motoko puede ser directamente compilado en **WebAssembly**, es un lenguaje incre칤ble para construir en el Internet Computer. Motoko es un lenguaje de alto nivel, que es f치cil de usar. Escribes en Motoko y luego es compilado para ti en WebAssembly.

<p align="center"> <img src="./assets/motoko_to_wasm.png" width="600px" style="border: 1px solid black;"/> </p>
<p align="center">En Motoko el c칩digo se hila , En WebAssembly se ejecuta.</p>

> Vale la pena se침alar que WebAssembly, fue co-dise침ado por [Andreas Rossberg](https://github.com/rossberg), quien se unio a la  DFINITY Foundation a principios de 2017 para trabajar en el entorno de ejecuci칩n canister smart contract y es adem치s el dise침ador original del lenguaje Motoko. La norma es mantenida por  [World Wide Web Consortium](https://www.w3.org/). 

En el siguiente ejemplo. podemos encontrar una funci칩n  `factorial`,ilustrada en **Motoko** y **WebAssembly**.
No te estreses si no entiendes nada - eso es normal:

<table align="center">
  <tr>
    <th> Motoko </th>
    <th>WebAssembly (Binary)</th>
  </tr>
<td><pre>
func factorial(n : Nat) : Nat {
    if(n == 0) {
        return 1
    } else {
        return factorial(n - 1);
    }
};
</pre></td>

<td><pre>
20 00
42 00
51
04 7e
42 01
05
20 00
20 00
42 01
7d
10 00
7e
0b
</pre></td>
</tr>
</table>
<p align="center"> 쯈u칠 opinas? Escribir esta funci칩n con < b > Motoko </b> parece f치cil? </p>

Un documento Motoko es un documento con la extensi칩n `mo`.

<p align="center"> <img src="./assets/mo_extension.png" width="300px" style="border: 2px solid black;"> </p>

**Motoko** es un lenguaje de alto nivel como **JavaScript** o **Python**. Generalmente es considerado m치s f치cil de aprender que un lenguaje de m치s bajo nivel como **Rust** o **C**. 

---
<i> Motoko tiene una mascota cool que ha sido intensivamente utilizada y modificada en la comunidad, para todo tipo de prop칩sitos!
Por lo que no solamente podr치s construir impresionantes aplicaciones con Motoko, sino que tambi칠n tendr치s el mejor logo de todos. 쯅o nos crees? Entonces te invito que veas el [Motoko NFT market](https://entrepot.app/marketplace/motoko) y compruebalo tu mismo. </i>

## El actor model.
Si tu abres un documento Motoko, hay una gran probabilidad de que la primera palabra que leas sea `actor`:
```
actor {

    /// CODE

};
````
Un **actor** es como un canister es representado y abstra칤do en **Motoko**. Estos t칠rminos vienen del [Actor model](https://en.wikipedia.org/wiki/Actor_model) el cual es una manera de escribir programas de ordenador que pueden manejar m칰ltiples tareas a la vez. Esto se consigue gracias a que los **actors** son tratados como los bloques b치sicos de un programa. <br/>
Un  actor es un peque침o programa de ordenador que puede recibir mensajes, realizar un trabajo y enviar mensajes a otros actors. Actors tambi칠n pueden crear nuevos actors y controlarlos. Todos los actors se comunican mediante el env칤o de mensajes. Dado que toda la interacci칩n entre los actores se realiza mediante el paso de mensajes, permite niveles muy altos de concurrencia y paralelismo, lo que lo hace muy adecuado para distributed systems. En ese sentido, **El Internet Computer es un ordenador distribuido donde cada programa es un canister !** 


Ya que los canisters han sido implementados para seguir el actor model - no te sorprender치s de aprender que los canisters:

- Tienen un private state (memoria) & pueden ejecutar c치lculos.
- Reciben mensajes de los usuarios u otros canisters.
- Pueden enviar mensajes  a los usuarios u otros canisters.
- Pueden crear otros canisters.


<p align="center"> <img src="./assets/actor_model.gif" width="800px" style="border: 2px solid black;"></p>
<p align="center">Un canister recibe un mensaje, lo ejecuta y posiblemente env칤a otro mensaje a otros canisters (o incluso crea uno nuevo) en respuesta. </p>

Consideremos el siguiente actor:
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```
Podemos ver que este actor tiene:
- Una variable llamada`message`, que es inicializada con el valor `Hello Motoko Bootcamp`.
- Dos funciones p칰blicas:
    - `changeMessage` la cual actualiza el valor de `message` a lo que sea que es proporcionado como argumento.
    - `readMessage` la cual muestra el valor de  `message` sin modificarlo. 

La palabra clave  `public` indica que ambas funciones pueden ser llamadas desde fuera por los usuarios u otros canisters. Las funciones  `public` de un actor representan la [API](https://en.wikipedia.org/wiki/API) de el canister. 
## Update vs Query
쯊e has dado cuenta de la palabra clave `query`en ejemplos anteriores? 
<br/> Cuando un usuario llama a un canister, es importante distinguir dos tipos de calls::

### Update calls
Update calls son usadas cuando el usuario quiere modificar el estado de un canister. Para asegurar la integridad del Internet Computer, estas calls deben ser procesadas a trav칠s de un consenso y por todos los nodos, lo que resulta en un retraso de alrededor de 1-2 segundos. Una update call ser치 usada en las siguientes situaciones:
- Publicar en redes sociales, como [DSCVR](https://dscvr.one/).
- Enviar un mensaje en una aplicaci칩n de mensajes, como [OpenChat](https://oc.app/).
- Enlazar o compartir contenido en [Distrikt](https://az5sd-cqaaa-aaaae-aaarq-cai.ic0.app/).
- Comprar un NFT en [Entrepot](https://entrepot.app/).

<p align="center"> <img src="./assets/update_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

### Query calls
Este tipo de call es usada cuando un usuario quiere leer datos sin modificar su estado.       Estas calls pueden ser respondidas por un solo node, haciendo que estas sean m치s r치pidas (alrededor de 200ms). La parte negativa es que **query** calls son menos seguras ya que un un node malicioso potencialmente puede proveer informaci칩n falsa. Una query call ser치 usada en las siguientes situaciones:
- Leer un art칤culo en [Nuance](https://nuance.xyz/).
- Revisar tu foto de perfil en 
- Cargar un video o una foto en cualquier plataforma.

<p align="center"> <img src="./assets/query_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

>Ya que una query call elude el consenso y recae en un 칰nico node, esta es menos segura que una update call.


|  | Update call | Query call |
|-----------------|-----------------|-----------------|
Tiempo de respuesta | 2-5 segundos 游냑  | 200-400 ms 丘뫮잺  |
Consenso| Yes | No |  
Lectura | Yes | Yes |
Escritura| Yes | No |
Coste | Cuesta cycles | Gratis (por ahora)


Volvamos a nuestro actor anterior
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```

La palabra clave `query` nos indica que la  funci칩n `readMessage` es solo para leer informaci칩n. En cambio, `readMessage` puede actualizar el estado (No necesitamos a침adir la palabra clave `update` ya que esta se asume por defecto). 

> Hemos desplegado el actor anterior en el Internet Computer - y tu puedes acceder <a href="https://a4gq6-oaaaa-aaaab-qaa4q-cai.raw.ic0.app/?id=rhjue-eaaaa-aaaaj-qazra-cai" target="_blank"> su API. </a> Prueba la interfaz y comprueba la diferencia de velocidades entre `changeMessage` & `readMessage`. Divi칠rtete y deja un mensaje amable para el siguiente estudiante.

## Combustible en el Internet Computer: cycles.
Para pagar el coste de computaci칩n y almacenamiento los canisters deben ser cargados con **cycles**.
Cada canister tiene su propio balance de **cycles**  - esto se puede entender como la bateria vital de un **canister**. 
**Cycles** pueden obtenerse mediante el quemado de **ICPs**.

<p align="center"> <img src="./assets/cycles_burned.gif" width="600px" style="border: 2px solid black;"> </p>
<p align="center"> Cuando se procesa un nuevo mensaje, los cycles son restados del balance del canister y son quemados.</p>

A diferencia de **gas** en **Ethereum**, **cycles** en el **Internet Computer** no son pagados por los usuarios. Esto significa que puedes interactuar con los canisters y navegar por sitios web sin pagar nada. Esto se conoce como el  **modelo reverse-gas** y es una gran mejora para la experiencia de los usuarios ya que elimina la necesidad de crear wallets, poseer tokens y pagar altas tasas.

Los Cycles se miden en trillones (T), lo que es equivalente a 1,000,000,000,000 o 10^12. Un trill칩n de cycles siempre costar치 1 XDR,el cual es una moneda basada en los tipos de cambio del mercado que representa una mayor basket(cesta) de la mayor칤a de monedas. En este momento, 1 XDR es equivalente a $1.34. El precio de los cycles no se ve afectado por el precio de los ICP tokens. En su lugar, el ratio de conversi칩n de ICP tokens a cycles es constantemente ajustado mediante la monitorizaci칩n del predio de ICP.

Cada operaci칩n realizada en la red tiene un coste vinculado a ella:
- Crear un canister.
- Ejecutar un mensaje actualizado.
- Ejecutar una inter-canister call.
- Almacenar datos.
- Realizar una HTTPS outcall.
- C치lculo de un threshold ECDSA signature.

El coste de estas operaciones tambi칠n depende en la subred donde estas son realizadas y el **factor de replicaci칩n** de esta subred. El factor de replicaci칩n corresponde al n칰mero de nodes en una subred, el cual puede comprender un rango de 13 a 40.
