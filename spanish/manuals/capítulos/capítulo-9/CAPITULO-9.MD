# Cap칤tulo 9: Manejo de errores.
En Motoko, cuando algo no funciona como se esperaba, hay varias formas de mostrar que se ha producido un error. Algunos m칠todos incluyen:
- Usando el tipo `Result`.
- Lanzar un error con la palabra clave `throw` o la biblioteca `Error`.
- Atrapar el programa.

En esta secci칩n veremos diferentes opciones y aprenderemos cu치ndo usar cada una para manejar errores de manera efectiva.
## 游뚼 El tipo `Result`.
El tipo `Result` es extremadamente 칰til en Motoko para manejar errores, se define como un tipo variante.
```motoko
type Result<Ok, Err> = {#ok : Ok; #err : Err}
```
Con `Ok` y `Err`, puedes especificar los tipos a devolver seg칰n el 칠xito o el fracaso. Por ejemplo, al crear un tipo de resultado para la graduaci칩n de un estudiante:
```motoko
type Score = Nat; // The score of a student. 
type ExamFailed = {
    #ScoreTooLow : Nat;     //  The score of the student. 
    #Absent;    //  One reason for not passing an exam.
    #Cheated;   //  Another reason for not passing an exam.
};
```
- Si un estudiante se grad칰a, se devuelve su puntaje. El puntaje es de tipo `Score`, que es un alias para `Nat`.
- Si un estudiante falla, se devuelve una variante que indica la raz칩n del fracaso. La variante es de tipo `ExamFailed`.

Ahora podemos utilizar esos nuevos tipos para reemplazar `Ok` y `Err`.
```motoko
type ExamResult = Result.Result<Score, ExamFailed>;
```
En casos como nuestro ejemplo, el uso de un tipo variante para `Err` es bastante com칰n. Permite un mejor manejo de diferentes tipos de errores y facilita la coincidencia de patrones. 춰Esto significa que cualquier persona que revise el error puede comprender mejor su causa espec칤fica!```motoko
func sendMessageToStudent(result : ExamResult) : Text {
    switch(result) {
        case(#ok(score)){
            return ("Congrats 游꿀 - you have graduated with a score of : " # Nat.toText(score));
        };
        case(#err(failure)){
            switch(failure){
                (#ScoreTooLow(score)){
                    return ("Unfortunately your score is below requirements. Next time you'll graduate! You had a score of : " # Nat.toText(score));
                };
                case(#Absent){
                    return ("You were absent at the exam. Please schedule another time.");
                };
                case(#Cheated){
                    return("Cheating is a short-term gain that leads to long-term pain");
                };
            };
        };
    };
};
```
### 쮺u치ndo debo usar el tipo Result?
El uso de `Result` para informar errores en tu API ofrece un beneficio significativo: permite a otros desarrolladores y programas manejar errores de manera predecible. Es por eso que `Result` se usa a menudo para errores esperados en tu programa cuando deseas devolver un valor. `Result` no afectar치 el comportamiento normal del programa.
## 游뿫 Trampas y afirmaciones
Una **trampa** es un tipo de error que ocurre durante la ejecuci칩n de un mensaje y no se puede resolver. Las causas m치s comunes de las trampas son:
- Divisi칩n por cero.
```motoko
let a : Nat = 5;
let b : Nat = 0;
let c = a / b;
```
- Index is out of bounds. 
```motoko
let names : [Text] = [];
```
- Assertion failure
```motoko
assert(false);
```
En algunas situaciones, puede ser 칰til atrapar intencionalmente, con un mensaje definido.

La mejor manera de hacerlo es usar el m칠todo `Debug.trap()` de la [biblioteca Debug](https://internetcomputer.org/docs/current/motoko/main/base/Debug), que te permite pasar un mensaje de error junto con la `trap`.```motoko
func trap(errorMessage : Text) : None
```
### Asserts
El uso de la palabra clave `assert` te permite verificar si se cumple una determinada condici칩n. Si la condici칩n dentro de `assert()` es `false`, el programa dejar치 de ejecutarse. Si es `true`, el programa continuar치 como de costumbre.
```motoko
assert(2 == 1);  // always traps
```
```motoko
assert n % 2 == 0; // traps only when n not even
```
```motoko
assert(true) // never traps
```
### 쮺u치ndo debo usar una trampa?
Las trampas detienen inmediatamente la tarea actual (es decir, el mensaje) que est치 siendo ejecutado por un contenedor, pero no impiden que el contenedor maneje solicitudes futuras. Las trampas deben usarse para situaciones inesperadas. Por ejemplo, la funci칩n `unwrap` a continuaci칩n:
```motoko
/// Unwraps the value of the option.
public func unwrap<T>(option : ?T) : T {
    switch option {
        case (?value)
            value;
        case null
            Debug.trap("Value is null - impossible to unwrap")
    }
};
```
> Las trampas tienen una caracter칤stica muy 칰til: si una funci칩n trapa, el estado del contenedor se revertir치. Esto se discutir치 m치s en el contexto de [llamadas entre contenedores](../chapter-11/CHAPTER-11.MD#commit-point-and-rollbacks).
## 游 Manejo de errores as칤ncronos con el tipo `Error` y try/catch.
> En esta secci칩n, el t칠rmino **error** se refiere espec칤ficamente a cualquier valor de tipo `Error`.

En Motoko, el manejo de errores puede ser un poco confuso, especialmente si est치s acostumbrado al manejo de errores en otros lenguajes de programaci칩n. Aqu칤 hay algunos puntos clave a tener en cuenta:

- Los errores se pueden lanzar usando la palabra clave `throw`.
- Los errores se pueden manejar mediante el patr칩n `try/catch`.
- Un error es del tipo `Error`, que tambi칠n se puede manipular utilizando la biblioteca Error.

Sin embargo, el manejo de errores en Motoko solo se puede hacer en un contexto as칤ncrono. Esto significa que solo puedes lanzar o atrapar errores en el cuerpo de una funci칩n compartida.
En este ejemplo, definimos un actor que contiene dos funciones: `throwErrorSync` y `throwErrorAsync`.
```motoko
import Error "mo:base/Error";
actor {
  // Misplaced throw 
  func throwErrorSync() : () {
    throw Error.reject("This will not work")
  };

  // Can throw an error in a shared/public function - this error will be consumed by another canister/user calling this function.
  public func throwErrorAsync() : async () {
    throw Error.reject("This will not work")
  };
}
```
> Puedes ver este ejemplo [en el Playground de Motoko](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=907568632) - nota el mensaje `misplaced throw` en el cuerpo de `throwErrorSync`.

El patr칩n `try/catch` en Motoko es particularmente 칰til cuando intentas llamar a otro contenedor y deseas manejar cualquier error posible que pueda ocurrir durante la llamada. Esto puede incluir situaciones como:

- El contenedor de destino no est치 activo o no se puede alcanzar.
- La funci칩n que se llama no existe en el contenedor de destino.
- La funci칩n que se llama trapa, ya sea debido a un error de programaci칩n o porque se ha quedado sin recursos.
- La funci칩n que se llama lanza un error que necesita ser manejado.

Suponiendo que este es nuestro contenedor A - desplegado con el ID de contenedor:
```motoko
actor {
    public func foo() : async Text {
        return "foo"
    };   
}
```
Asumiendo que este es nuestro canister B
```motoko
actor {

    let canisterA = actor("xxx") : actor {
        foo : shared () -> async Text;
    };

    public func fooFromCanisterA() : async Text {
        try맡
            let foo = await canisterA.foo()
            return foo;
        } catch (e) {
            return "An error occured when calling canister A".
        };
    };   
}
```
En el ejemplo proporcionado, tenemos dos contenedores: **Contenedor A** y **Contenedor B**.
- **Contenedor A** tiene una sola funci칩n p칰blica `foo` que devuelve el texto "foo".
- **Contenedor B** tiene una funci칩n p칰blica `fooFromCanisterA` que intenta llamar a la funci칩n `foo` en **Contenedor A** utilizando el patr칩n `try/catch`. Si la llamada a `canisterA.foo()` tiene 칠xito, la funci칩n devuelve el valor de `foo`. Si se produce un error durante la llamada, se captura mediante el bloque catch y la funci칩n devuelve el texto `"Se produjo un error al llamar al contenedor A"`.

Este ejemplo ilustra c칩mo el patr칩n `try/catch` se puede utilizar para manejar errores al llamar funciones en otros contenedores, asegurando que tu programa contin칰e ejecut치ndose correctamente incluso si se produce un error durante la llamada.

## 游뱂 Palabras finales
Lidiar con todas estas situaciones diferentes y formas de manejar problemas inesperados puede ser confuso al principio, especialmente cuando se trata del modelo `actor` y contextos as칤ncronos. Pero no te preocupes si no lo entiendes todo de inmediato. La mejor manera de entenderlo es practicar y a medida que encuentres diferentes situaciones, tu comprensi칩n se fortalecer치. 
